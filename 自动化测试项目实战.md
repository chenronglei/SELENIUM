# 11.1 自动化测试用例设计  
## 11.1.1 手工测试用例与自动化测试用例
手工测试用例是针对功能测试人员的，而自动化测试用例则是针对自动化测试框架或工具的  
- 手工测试用例特定:  
较好的异常处理能力，能通过人为的逻辑判断校验当前步骤的功能是否正确实现  
人工执行用例具有一定的步骤跳跃性  
人工测试步步跟踪，能够细致定位问题  
主要用来发现功能缺陷  
- 自动化测试用例特点:  
执行对象是脚本，任何一个判断都需要编码定义  
用例步骤之间关联性强  
主要用来保证产品主体功能正确和完整，让测试人员从繁琐重复的工作中解脱出来  
目前自动化测试阶段定位在冒烟测试（针对之前发现的bug进行的测试）和回归测试  
- 自动化测试用例选型注意事项:  
不是所有的手工用例都要转为自动化测试用例  
考虑到脚本的开发的成本，不要选择流程太复杂的用例  
选择的用例最好可以构建成场景。例如，一个功能测试模块，分成多个用例，多个用例使用同一个场景。这样的好处是方便构建关键字测试模型  
选择的用例可以带有目的性  
选择的用例可以是你认为是重复执行，很繁琐的部分。例如，字段验证、提示信息验证这类，这部分适合于回归测试  
选取的用例可以是主体流程，适用于冒烟测试  
自动化测试也可以用来做配置检查、数据库检查。这些可能超越了手工用来  
平时在手工测试时，如果需要构造以下复杂的数据或重复以下简单的机械式动作，则告诉自动化脚本  
## 11.1.2 测试类型  
- 静态测试内容  
静态内容测试是最简单的测试，用于验证静态的、不变化的UI元素的存在性  
- 测试链接  
Web站点的一个常见错误为失效的链接或链接指向无效页。链接测试设计各个链接和验证预期的页面是否存在。如果静态链接不经常更改，则手动测试就足够了。但是，如果你的网页设计师经常改变链接，或者文件不时被重定向，则链接测试应该实现自动化  
- 功能测试  
功能测试通常是需要自动化测试的最复杂的测试类型，但通常也是最重要的  
- 测试动态元素  
- Ajax的测试  
Ajax是一种支持以及动态改变用户界面元素的技术  
## 11.1.3 自动化测试用例的编写原则
1)一个用例为一个完整的场景，从用户登陆系统到最终退出并关闭浏览器  
2)一个用例只验证一个功能点，不要试图在用户登陆系统后把所有的功能都验证一遍  
3)尽可能少的编写逆向逻辑用例  
4)用例和用例之间尽量避免产生依赖  
5)一条用例完成测试之后需要对测试场景进行还原，以免影响其他用例的执行  
# 11.2 BBS社区项目实战  
BBS社区属于互联网比较典型的应用，主要有登陆、个人中心、发帖、查看帖子、搜索、签到等功能  
## 11.2.1 准备工作  
1.项目开发是个循序渐进的过程  
2.选择合适的IDE  
Python IDLE :初学Python  
## 11.2.2 项目结构介绍  
mztestpro/  
&nbsp;&nbsp;&nbsp;&nbsp;bbs/  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data/  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;report/  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image/  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test_case/  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;models/  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;driver.py  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function.py  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myunit.py  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;page_obj/  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*Page.py  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*_sta.py  
&nbsp;&nbsp;&nbsp;&nbsp;driver/  
&nbsp;&nbsp;&nbsp;&nbsp;package/  
&nbsp;&nbsp;&nbsp;&nbsp;run_bbs_test.py  
&nbsp;&nbsp;&nbsp;&nbsp;start.bat  
&nbsp;&nbsp;&nbsp;&nbsp;自动化测试项目说明文档.docx  

1.mztestpro测试项目  
bbs:用于存放BBS项目的测试用例、测试报告和测试数据等  
driver:用于存放浏览器驱动。如selenium-server-standalone.jar、chromedriver.exe等  
package:用于存放自动化所用到的扩展包。例如，HTMLTestRunner.py属于一个单独的模块，并且对其做了修改  
run_bbs_test.py:项目主程序，用来运行社区(BBS)自动化用例  
startup.bat:用于启动Selenium Server,默认启动driver目录下的selenium-server-standalone  
自动化测试项目说明文档.docx: 介绍当前项目的框架、配置和使用说明  
2.bbs目录  
data: 该目录用例存放测试相关的数据  
report: 用来存放HTML测试报告。其下面创建了image目录用于存放测试过程中的截图  
test_case: 测试用例目录，用于存放测试用例及相关模块  
3. test_case目录  
models: 该目录下存放了一些公共的配置函数及公共类  
page_obj: 该目录用于存放测试用例的页面对象（Page Object)。根据自定义规则，以“*Page.py”命名的文件为封装的页面对象文件  
*_sta.py: 测试用例文件。根据测试文件匹配规则，以“*_sta.py”命名的文件将被当作自动化测试用例执行  

## 11.2.3 编写公共模块  
定义驱动文件:  
...\mztestpro\bbs\test_case\models\driver.py  

> from selenium.webdriver import Remote  
from selenium import webdriver  
#启动浏览器驱动  
def browser():  
&nbsp;&nbsp;&nbsp;&nbsp;#运行主机:端口号（本机默认:127.0.0.1:4444)  
&nbsp;&nbsp;&nbsp;&nbsp;host = '127.0.0.1:4444'  
&nbsp;&nbsp;&nbsp;&nbsp;#指定浏览器（'chrome','firefox'）  
&nbsp;&nbsp;&nbsp;&nbsp;dc = {'browserName':'chrome'}  
&nbsp;&nbsp;&nbsp;&nbsp;driver = Remote(command_executor='http://' + host + '/wd/hub',desired_capabilities=dc)  
&nbsp;&nbsp;&nbsp;&nbsp;return driver  
if __name__ == '__main__':  
&nbsp;&nbsp;&nbsp;&nbsp;dr = browser()  
&nbsp;&nbsp;&nbsp;&nbsp;dr.get("http://www.baidu.com")  
&nbsp;&nbsp;&nbsp;&nbsp;dr.quit()  
 
 
上例  可以根据我们的需求，配置测试用例在不同的主机及浏览器下运行  

自定义测试框架类:
...\mztestpro\bbs\test_case\models\myunit.py  

> from selenium import webdriver  
from driver import browser  
import unittest  
import os
class MyTest(unittest.TestCase):  
&nbsp;&nbsp;&nbsp;&nbsp;def setUp(self):  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.driver = browser()  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.driver.implicitly_wait(10)  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.driver.maximize_window()  
&nbsp;&nbsp;&nbsp;&nbsp;def tearDown(self):  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.driver.quit()  

定义MyTest()类用于继承unittest.TeseCase类，因为笔者创建的所有测试类中setUp()与tearDown()方法所做的事情相同，将它们抽象为MyTest()类，好处就是在编写测试用例时不再考虑这两个方法的实现  

定义截图函数:
...\mztestpro\bbs\test_case\models\function.py  

> from selenium import webdriver  
import os  
#截图函数  
def insert_img(driver,file_name):  
&nbsp;&nbsp;&nbsp;&nbsp;#__file__是获取当前执行主脚本的路径 E:\python\3.6\11\mztestpro\bbs\test_case\models\function.py  
&nbsp;&nbsp;&nbsp;&nbsp;#os.path.dirname(__file__)获取到的是E:\python\3.6\11\mztestpro\bbs\test_case\models  
&nbsp;&nbsp;&nbsp;&nbsp;#os.path.dirname(os.path.dirname(__file__))获取到的是E:\python\3.6\11\mztestpro\bbs\test_case  
&nbsp;&nbsp;&nbsp;&nbsp;base_dir = os.path.dirname(os.path.dirname(__file__))  
&nbsp;&nbsp;&nbsp;&nbsp;base_dir = str(base_dir)  
&nbsp;&nbsp;&nbsp;&nbsp;base_dir = base_dir.replace('\\','/')  
&nbsp;&nbsp;&nbsp;&nbsp;base = base_dir.split('/test_case')[0]  
&nbsp;&nbsp;&nbsp;&nbsp;file_path = base + '/report/image/' + file_name  
&nbsp;&nbsp;&nbsp;&nbsp;driver.get_screenshot_as_file(file_path)  
if __name__ == '__main__':  
&nbsp;&nbsp;&nbsp;&nbsp;driver = webdriver.Chrome()  
&nbsp;&nbsp;&nbsp;&nbsp;driver.get("https://www.baidu.com")  
&nbsp;&nbsp;&nbsp;&nbsp;insert_img(driver,'baidu.png')  
&nbsp;&nbsp;&nbsp;&nbsp;driver.quit()  


    
    
       






